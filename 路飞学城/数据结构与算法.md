## 算法基础知识

```python
算法  一个计算的过程，解决问题的方法    程序=数据结构+算法

复杂度
1.时间复杂度（单位）
概念：用来评估算法运行效率的式子
常见时间复杂度    O(1)<O(logn)<O(n)<O(nlogn)<O(n*2)<O(n*2logn)<O(n*3)
简单快速判断时间复杂度（大多是情况）
	-- 确定问题规模-->n
    -- 循环减半的过程-->logn
	-- k层关于n的循环-->n*k

2.空间复杂度
概念：用来评估算法内存占用大小的式子

空间换时间

递归
特点：
	1.自己调用自己
	2.问题规模逐渐减小
	3.结束条件
    
汉诺塔问题
	1.将n-1个盘子从a经过c移动到b
    2.将第n个盘子从a移动到c
    3.将n-1个盘子从b经过a移动到c
    
    def hanoi(n, a, b, c):
    if n > 0:
        hanoi(n - 1, a, c, b)
        print(f'从{a}移动到{c}')
        hanoi(n - 1, b, a, c)
```



## 常见查找算法

```python
概念：从列表中查找指定元素   输入：列表    待查找元素   输出 :   元素下标（未找到返回None）内置函数：index()---顺序查找
```



**顺序查找**

```python
顺序查找（LineSearch）从列表第一个元素开始，顺序进行搜索，直到找到元素或者列表最后一个元素。 时间复杂度：O(n)
def linesearch(li, n):
    for index, val in enumerate(li):
        if val == n:
            return index
    return
```

**二分查找**

```python
二分查找（binary_search） 前提有序列表     时间复杂度O(logn)
def binary_search(li,val):
    left=0
    right=len(li)-1
    while left<=right:  #代表候选区还有值
        mid=(left+right)//2
        if li[mid]==val:
            return mid
        elif li[mid]>val:   #待查的值小于中间的值  待查值在左侧
            right=mid-1
        else:     #待查的值大于中间的值   待查的值在右侧
            left=mid+1
    return
```



## 常见排序算法



```python
概念：将一组无序的记录列表调整为有序的记录列表    内置函数sort()
```

**冒泡排序**

```python
1.比较相邻俩个元素，如果前面的比后面的大，则交换这俩个元素
2.一趟排序完成后，有序区增加一个，无序区减少一个
复杂度O(n*2)
def bubble_sort(li):
    for i in range(len(li)-1):  #一共是n-1趟
        exchange=False
        for j in range(len(li)-i-1):    #指针位置
            if li[j]>li[j+1]:
                li[j+1],li[j]=li[j],li[j+1]
                exchange=True
        if not exchange:    #如果一趟中没有元素发生交换就返回li
            return li
    return li
```



**选择排序**

```python
1.遍历无序区选出最小的位置
2.将最小值位置与无序区第一个元素交换
3.一趟排序完成后，有序区增加一个，无序区减少一个
复杂度O(n*2)
def select_sort(li):
    for i in range(len(li) - 1):
        min_loc = i  # 假设无序区第一个元素就是最小值位置
        for j in range(i + 1, len(li)):  # 无序区
            if li[min_loc] > li[j]:
                min_loc = j
        li[i], li[min_loc] = li[min_loc], li[i]  # 将最小值位置的元素和无序区第一个元素交换
        print(li)
    return li
```



**插入排序**

```python
将无序区的元素和有序区的元素依次比较，选择合适的位置放入
复杂度O(n*2)
def  insert_sort(li):
    #默认把第一个元素作为有序区的元素
    for i in range(1,len(li)):   #无序区元素的下标，也是插入的次数
        tmp=li[i]
        j=i-1  #有序区元素的下标
        while j>=0:
            if li[j]>tmp:
                li[j+1]=li[j]
                i=j
                j-=1
            else :
                li[j+1]=tmp
                break

        li[j+1]=tmp
    return li

print(insert_sort([1,2,3,6,4,3,0]))
```



**快速排序**

```python
1.取出一个元素，使p归位
2.列表被分为俩部分，左边比p小，右边比p大
3.递归完成排序
def partition(li, left, right):
    #取出一个数
    tmp = li[left]
    while left < right:
        while left < right and li[right] >= tmp:  #从右边找到比tmp小的数，放到左边的空位
            right -= 1
        li[left] = li[right]
        print(li)
        while left < right and li[left] <= tmp: #从左边找到比tmp大的数，放到右边的空位
            left += 1
        li[right] = li[left]
        print(li)
    #将取出的数归位，此时左边的数比tmp小，右边的数比tmp大
    li[left] = tmp
    return left
def quick_sort(li,left,right):
    if left
```



**堆排序**

```python
满二叉树：一个二叉树每层节点数都达到最大值
完全二叉树：叶子节点只能出现在最下层和次下层，最下层节点可以不满，但是从左至右依次排开


大根堆：一颗完全二叉树，满足任意节点都比其孩字节点大
小根堆：一颗完全二叉树，满足任意节点都比其孩子节点小
堆排序过程
	1.建立堆
    2.得到堆顶元素为最大值
    3.去掉堆顶，将堆的最后一个元素放到堆顶，此时可以通过一次向下调整重新使堆有序
    4.堆顶元素为第二大元素
    5.重复3的步骤直至堆变空
堆的向下调整
    当根节点的左右子树都是堆，但自身不是堆，可以通过一次向下调整变成堆
    def sift(li, low, hight):
    '''

    :param li: 列表
    :param low: 指向堆的根节点
    :param height: 指向堆的最后一个位置
    :return:
    '''
    i = low  # 刚开始指向堆的根节点
    j = i * 2 + 1  # 指向左孩子节点
    tmp = li[low]  # 把堆顶存起来
    while j <= hight:
        if j + 1 <= hight and li[j + 1] > li[j]:  # 如果右孩子节点且比左孩子节点要大
            j = j + 1  # 指向右节点
        if li[j] > tmp:  # 最大孩子节点比tmp要大，把其放到父节点上
            li[i] = li[j]
            i = j
            j = j * 2 + 1  # 指向j的左孩子节点，如果没有退出循环
        else:  # tmp更大放到i的位置
            li[i] = tmp
            # 所以的点都找到他其对应的位置
            break
    # i 没有孩子节点 把tmp放到i的位置
    li[i] = tmp
    return li

li = [7, 8, 9, 6, 5, 4, 3]
print(sift(li, 0, len(li) - 1))



堆排序的应用 topk问题
import heapq, random

li = [i for i in range(100)]
# 将列表打乱
random.shuffle(li)
k = int(input("输入要查询的k"))


# 将前k个元素建立成堆,并输出前k大的值
def heapq_k(li):
    my_li = li[:k]
    # 建立小根堆，堆顶为最小值
    heapq.heapify(my_li)
    # 遍历列表，选出前k大的数
    for i in range(k, len(li)):
        if my_li[0] < li[i]:  # 将大于堆顶的数与堆顶进行交换
            my_li[0], li[i] = li[i], my_li[0]
            heapq.heapify(my_li)
    return my_li


topk_li = heapq_k(li)
print(topk_li)
for i in range(k):
    print(heapq.heappop(topk_li))
```



**并归排序**

```python
归并：将俩个有序列表，合并成一个有序列表
步骤
	1.分解 列表越来越小，直至一个元素
    2.终止条件：一个元素是有序的
    3.合并：将俩个列表并归，列表越来越大

```



**希尔排序**



**计数排序**



**桶排序**